实训项目：电信计费系统之DMS数据采集子系统项目开发流程
	
面向对象的软件设计方法
综合运用所学知识：C/C++、UNIX/LINUX内核编程、数据结构和算法、QT界面编程、ORACLE/Pro*C;
1. 项目开发流程
	1. 需求分析
	用软件工程的专业语言复述(归纳、整理)用户的业务需求。
					
	业务和专业。
	1. 用例		：功能性描述。
	2. 参与者	：参与实现功能的具体角色。
	3. 时间流	：参与者为了实现功能所必须经历的过程。
	4. 异常流	：针对事件流中的各种意外所提供的对策。
	5. 前置条件	：事件流中每个环节所依赖的前提。
	6. 后置条件	：事件流中每个环节所提供的成果。

	《需求规格说明书》
	《演示(demo)系统》

	2. 概要设计
	主架构	-----面向过程, 关注事件流。
		-----面向对象，关注参与者。

	找到对象是面对对象主架构设计最关键的一步。
	事件流描述：读取文件，形成记录。

	数据驱动亦称模型驱动：关注事件流中的名词、将其作为对象，动词成为他们的行为，为了实现这些行为必须满足的前置条件、后置条件成为对象的属性。

	行为驱动也称接口驱动：关注事件流中的动词，将其施动者识别为对象，该动词即为对象的行为，其宾语以属性的形式充当该对象的前置或者后置条件。

	故障驱动亦称异常驱动：关注异常流，从各种异常中识别对象。
	实践通常是三种驱动方式综合使用。
	《概要设计说明书》
	根据《概要设计说明书》制定《研发计划》 和 《测试计划》

	3. 详细设计
	将对象抽象化为类，形成类图、时序图、活动图和状态图。
	《详细设计说明书》 和各种图

	4. 编写代码/编写测试用例

	5. 测试/修改/验证

	6. 产品发布/工程实施

	7. 项目总结
		
		2. 项目背景介绍
			
		3. 数据采集客户机
			1. 用例描述
				数据采集客户机备份并读取用户登录日志文件，形成匹配日志记录，通过网络发送给数据采集服务器。

			2. 参与者
				系统管理员、数据采集客户机、日志读取器、日志发送器。

			3. 基本事件流
				1. 备份系统登录日志，产生备份文件，以系统日期和时间作为后缀，如：
					wtmpx.20160606091800，同时清空原始系统登录日志，以备记录新日志记录。

				2. 读取备份日志文件，产生登入退出记录：
					登录名、登录IP、登录进程PID、登入/退出时间。

				3. 匹配登入/退出日志记录，产生匹配日志记录，包括如下信息：
					登录名、登录IP、登录进程PID、登录时间、退出时间、登录时段。

				4. 根据数据采集服务器的IP地址和侦听接口端口号，近路TCP连接；

				5. 将匹配日志记录逐条发送到数据采集服务器。
					备份	\
					读取	->日志读取器\
					匹配	/			数据采集->系统管理员
					连接	\			/客户机
						->日志发送器
					发送/
					绘制《用例图》

			4. 可选事件流：无

			5. 异常事件流
				1. 备份系统登录日志失败，终止采集，提示用户；

				2. 读取备份日志文件失败、终止采集、提示用户；

				3. 匹配过程中出现异常：
					1. 只有登入记录没有退出记录，将登入记录存入登入文件，以备下次匹配。
					2. 只有退出记录没有登入记录，直接忽略。

				4. 连接数据采集服务器失败：将全部匹配日志记录保存到发送失败文件中，以备下次重发；

				5. 发送过程中出现发送失败：将未发送匹配日志记录保存到发送失败文件中，以备下次重发；

			6. 前置条件	
				1. 系统登入日志文件路径：/var/adm/wtmpx。

				2. 登入文件的路径：./logins.dat。

				3. 发送失败文件的路径：./fail.dat。
				
				4. 数据采集服务的IP地址和侦听端口号。

			7. 后置条件：匹配日志记录集
				分析				设计
				参与者				->对象。
				事件流				->对象的行为->成员函数。
				异常流				->各种意外->异常对象。
				前置条件和后置条件	->对象的属性->成员变量。

			8. 概要设计：结构框图/架构图

			9. 设计：《类图》、《时序图》、《活动图》和《状态图》
				Rational Rose/IBM Rose

			10. 编写代码


四. 数据采集服务器
1. 用例描述
数据采集服务通过网络接收数据采集客户机上传的匹配日志记录，保存到数据库中。
2. 参与者
	1. 并发问题
	2. I/O吞吐量问题
	系统管理员，数据采集服务器，服务器套接字，客户线程，日志队列，存储线程，数据访问对象，数据库
	《用例图》

3. 基本事件流
	1. 接收匹配日志记录
		A. 建立服务器侦听套接字
		B. 等待并接受客户机的连接请求
		C. 创建客户线程，接收客户机上传的匹配日志记录
		D. 客户线程将其所接收到的匹配日志记录压入日志队列

	2. 保存匹配日志记录
		A. 创建数据访问对象，建立和数据库的连接
		B. 创建存储线程
		C. 存储线程监视日志队列，从中弹出匹配日志记录
		D. 将日志记录通过数据访问对象保存到数据库中
		E. 当数据访问对象被销毁时，关闭和数据库的连接

				   数据采集服务器
                                  /               |
                         服务套接字		  |
                             |                    |
			     V                    V
		客户机 -> 客户线程 -> 日志队列 -> 存储线程 -> 数据访问对象 -> 数据库
		|<--------接收---------->|<----------------保存----------------->|
----------------------------------------------------------------------------------------

生产者-消费者模型和线程同步
生产者：数据或资源的缔造者，如客户线程；
消费者：数据或资源的使用者，如存储线程；
线程之间的关系：异步，同步，边际同步。

撑死：缓冲区满，生产者等待消费者消费，腾出空间再继续生产。
饿死：缓冲区空，消费者等待生产者生产，有了产品再继续消费。
当边际条件发生时，线程之间需要建立停-等机制，以实现边际同步。

UNIX/LINUX环境的线程同步机制：
1. 互斥锁，解决并发冲突问题。
2. 信号量，解决资源分享问题。
3. 条件量，解决停等同步问题。当某种条件得不到满足时，线程可以停止运行（挂起，进入睡眠），直到条件满足再恢复运行（解除挂起，从睡眠中被唤醒）。

生产者    			消费者
if(!仓库非满)			if(!仓库非空)
   睡眠，等待仓库非满		    睡眠，等待仓库非空
生产产品，唤醒消费者		消费产品，唤醒生产者

1. 创建条件量

int pthread_cond_init(pthread_cond_t* cond, pthread_condattr_t const* attr);
cond - 输出参数，条件量ID
attr - 输入参数，条件量属性，取NULL表示缺省属性
返回错误码

静态方式创建：
	pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

2. 销毁条件量

int pthread_cond_destroy(pthread_cond_t* cond);
cond - 输入，条件量ID，只有通过pthread_cond_init()函数动态创建的条件量才需要通过
pthread_cond_destroy()销毁

3. 等待条件量

int   pthread_cond_wait(pthread_cond_t* cond, pthread_mutex_t* mutex);
使调用线程睡眠于条件量cond，同时释放互斥锁mutex。返回错误码。

4. 唤醒条件量

int pthread_cond_signal(pthread_cond_t* cond);
唤醒睡眠于条件量cond中的/*任一线程*/，该线程在重新获得所释放的互斥锁以后从内核返回。返回错误码。


int pthread_cond_broadcast(pthread_cond_t* cond);
唤醒睡眠于条件量cond中的/*所有线程*/，但是只有一个线程重新获得所释放的互斥锁以后从内核返回。返回错误码。

-----------------------------------------------------------------------------------------


4. 事件流：无

5. 异常事件流
	1. 数据库异常   \
	2. 网络异常      > 终止采集，提示用户
	3. 线程异常     /

6. 前置条件
	1. 绑定IP地址和端口号
	2. 数据库的用户名和口令

7. 后置条件：数据库中的匹配日志记录

8. 类图，时序图，活动图和状态图

---------------------------------------------------------------------------------------------

线程封装
class Thread{
public:
	void start(void){
		pthread_create(&m_tid, NULL, run, NULL);
	}
	void run(void* arg){
		//线程任务
	}
private:
	pthread_t m_tid;
};

---------------------------------------------------------------------------------------------

五. 自动定时启动数据采集客户机

通过 crontab -e 命令编辑定时任务配置文件
A B C D E <命令>

UNIX/LINUX操作系统的定时任务进程，每间隔一分钟，检查crontab配置文件，如果当前系统时间符合ABCDE所确定的时间规制，那么就执行其后的<命令>
A：分钟，[0,59]
B：小时，[0,23]
C：日，[1,31]
D：月，[1,12]
E：星期，[0,6]，0表示星期日
ABCDE都可以用通配符 "*" 表示任意，即不限制
15 * * * 1-5 <命令>
0,30 * * * 1-5 <命令>
* * * * * <命令>
0 * * * * <命令>


六. 为数据采集客户机增加图形用户界面
QThread
	strat - 启动线程
	static run - 线程过程
	virtual run =0 -线程处理
WorkThread:QThread
	run - 线程任务
















