关键字：

一. proc中如何使用sql语句
1. select 语句   只要在语句前加exec sql，并结合into使用
	exec sql select first_name into :var_name 
		from s_emp where id=1;

2. ddl语句（create drop alter）
   dml语句（insert delete update）
   tcl语句（commit rollback savepoint）	
   直接在语句前加exec sql即可
   ddl中不能使用宿主变量



  1 #include<stdio.h>                                                           
  2 exec sql include sqlca;
  3 
  4 int main()
  5 {
  6     exec sql begin declare section;
  7      char userpasswd[30]="openlab/open123";
  8      int id=100;
  9      char name[30]="test";
 10     exec sql end declare section;
 11     exec sql connect:userpasswd;
 12     
 13     /*ddl建表*/
 14     exec sql create table testprocsql_wkw(
 15             id number primary key, 
 16             name varchar2(30)  
 17             );
 18     if(sqlca.sqlcode==0)
 19         printf("建表成功！\n");
 20     else
 21         printf("%s\n",sqlca.sqlerrm.sqlerrmc);
 22         
 23     /*dml写入数据*/
 24     exec sql insert into testprocsql_wkw values(:id,:name);
 25     
 26     /*dml 更新 把id=100的name改为test99*/   
 27     exec sql update testprocsql_wkw
 28         set name='test99' where id=:id; 
 29     
 30     /*tcl提交*/
 31     exec sql commit;
 32     
 33     /*select 查询id=100的name并输出*/
 34     exec sql select name into :name 
 35         from testprocsql_wkw where id=:id;
 36     printf("name=%s\n",name);
 37 
 38     exec sql commit work release;
 39 
 40 }                                               

[oracle@centos wkw]$ ./a.out 
ORA-00955: name is already used by an existing object
                
name=test99                       

-------------------------------------------------------------------------


二. proc中如何使用plsql语句
1. 使用plsql的语法
	exec sql execute
		begin
			/*这里相当于plsql的匿名块*/
		end;
	end-exec;


在proc预编译时，需要两个选项
	sqlcheck=semantics
	userid=用户名/密码
		userid的意思是在预编译的时候连接数据库，验证调用的存储过程或者函数是否存在和合法
		sqlcheck=semantics  就是检查语义是符合要求



2. 在proc中调用存储过程
	a.写一个存储过程 传入两个参数，然后把两个参数之和存入到第二个参数
	  create or replace procedure 过程名（参数列表）
	  is
		/*临时变量*/
	  begin

	  end;
	

		create or replace procedure getsum(
		    	var_a in number,var_b in out number)
	     	is
	    	begin
	      		var_b:=var_a+var_b;
			dbms_output.put_line(var_b);
	   	end;


	b.写一个proc程序调用存储过程
		  1 #include<stdio.h>
		  2 exec sql include sqlca;
		  3 
		  4 int main()
		  5 {
		  6     exec sql begin declare section;
		  7      char userpasswd[30]="openlab/open123";
		  8      int var_a=100;
		  9      int var_b=1;
		 10     exec sql end declare section;
		 11     exec sql connect:userpasswd;
		 12 
		 13     exec sql execute
		 14         begin
		 15             getsum(:var_a,:var_b);
		 16         end;
		 17     end-exec;
		 18 
		 19     printf("b=%d\n",var_b);
		 20 
		 21     exec sql commit work release;
		 22 
		 23 }


		结果：
			b=101




3. proc中调用函数
	a.设计一个函数，传入两个参数，返回两个数中的较大值
		create or replace function 函数名（参数列表）
		return 数据类型
		is
			/*临时变量*/
		begin
			
		end;


			create or replace function getmax(
				x in number,y in number)
			return number
			is
			begin
			  	if x>y then
					return x;
			  	end if;
			  	return y;
			end;	


	b.写一个proc程序，调用函数
		  1 #include<stdio.h>
		  2 exec sql include sqlca;
		  3 
		  4 int main()
		  5 { 
		  6     exec sql begin declare section;
		  7      char userpasswd[30]="openlab/open123";
		  8      int a=100; 
		  9      int b=1; 
		 10      int var_max;
		 11     exec sql end declare section;
		 12     exec sql connect:userpasswd;
		 13 
		 14     exec sql execute
		 15         begin
		 16             :var_max:=getmax(:a,:b);     --注意var_max 前面的冒号  var_max也是宿主变量
		 17         end;
		 18     end-exec;
		 19     
		 20     printf("max=%d\n",var_max);
		 21 
		 22     exec sql commit work release;
		 23 }   


		结果：
			max=100




三. 数据库连接
1. 本地数据库
	exec sql connect:用户名/密码;
	exec sql connect:用户名 identified by :密码


2. 远程数据库
	连接方式：
		char userpasswd[20]="openlab/open123";
		char dbstring[20]="remoteDB";
		exec sql connect:userpasswd using :dbstring;
	remoteDB 是网络服务名，在$ORACLE_HOME/network/admin/tnsnames.ora文件中定义



	  1 # tnsnames.ora Network Configuration File: /home/oracle/app/oracle/product/1    1.2.0/dbhome_1/network/admin/tnsnames.ora
	  2 # Generated by Oracle configuration tools.
	  3 
	  4 LISTENER_ORCL =
	  5   (ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521))
	  6 
	  7 
	  8 ORCL =
	  9   (DESCRIPTION =
	 10     (ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521))
	 11     (CONNECT_DATA =
	 12       (SERVER = DEDICATED)
	 13       (SERVICE_NAME = orcl)
	 14     )
	 15   )
	 16 

	需要提供一个描述，描述远程数据库。包括：ip地址，端口号，oracle数据库的服务ID（服务名）

	在$ORACLE_HOME/network/admin/tnsnames.ora 文件中已经写好，改一下就可以
	环境变量 通常大写
	ORACLE_HOME:oracle的安装目录
	echo $ORACLE_HOME
	echo $ORACLE_HOME  输出oracle的安装目录
  	echo $PATH  输出系统路径

	端口号：默认1521
	有了远程数据库的描述后，在连接时用using引入描述变量
  	exec sql connect:用户名/密码 using :描述变量



四. proc中异常处理
1. 局部异常处理
	sqlca.sqlcode 来判断sql语句执行状态

2. proc中的全局异常处理
	异常处理的代码只写一次，当出错时自动去找
	exec sql whenever 条件 动作;
	条件就是错误的方式 动作就是出错后的处理方式
	条件包括3种：
	sqlerror 	--sql语句出错
	notfound	--没有找到数据
	sqlwarning	--sql语句被警告（不太常用）

	动作包括：
	do 错误处理的函数();	--条件发生后，调用函数
	do break;		--退出循环
	continue;		--继续运行
	stop;			--停止执行（不常用）
	goto 标签;		--跳转到某个位置（不常用）


3. 举例
	删除一张不存在的表	table_dddd

	proc中默认对异常不处理的
	出现异常时（sqlerror notfound），向上查找对应的whenever语句，如果找到了，执行动作后继续。如果找不到，不作处理，继续执行下面的代码
	

五. proc中的数据处理
1. 单行单列的查询  用宿主变量解决
	exec sql select first_name into :name 
		from s_emp where id=1;

2. 单行多列 用多个宿主变量 或者 结构体 解决
	exec sql select manager_id,first_name into :mid,:name
		from s_emp where id=1;

3. 多行单列的查询 用数组解决
	exec sql select first_name into :namers
		from s_emp;

4. 多行多列的查询 用多个数组 或 结构体数组 或者 游标 解决
	exec sql select id,first_name into :ids,:names 
		from s_emp

	
	a.用结构体解决单行多列的查询问题
		
	  1 #include<stdio.h>
	  2 exec sql include sqlca;
	  3 struct emp{
	  4     int id;
	  5     char name[30];
	  6     double salary;
	  7 };
	  8 
	  9 int main()
	 10 {
	 11     exec sql begin declare section;
	 12      char userpasswd[30]="openlab/open123";
	 13      struct emp em;  
	 14     exec sql end declare section;
	 15     exec sql connect:userpasswd;
	 16     
	 17     exec sql select id,first_name,salary into :em 
	 18         from s_emp where id =1;
	 19     exec sql commit work release;
	 20 
	 21     printf("%d,%s,%lg\n",em.id,em.name,em.salary);
	 22     return 0; 
	 23 }   

	结果：
	1,Apple                        ,23500




	b.用结构体数组解决多行多列的查询问题

	  1 #include<stdio.h>
	  2 exec sql include sqlca;
	  3 struct emp{
	  4     int id;
	  5     char name[30];
	  6     double salary;
	  7 };
	  8 
	  9 int main()
	 10 {
	 11     exec sql begin declare section;
	 12      char userpasswd[30]="openlab/open123";
	 13      struct emp ems[50];     
	 14     exec sql end declare section;
	 15     exec sql connect:userpasswd;
	 16     
	 17     exec sql select id,first_name,salary into :ems
	 18         from s_emp;
	 19     exec sql commit work release;
	 20     int i=0;
	 21     for(i=0;i<sqlca.sqlerrd[2];i++)
	 22     {   
	 23         printf("%d,%s,%lg\n",ems[i].id,ems[i].name,ems[i].salary);
	 24     }   
	 25     return 0; 
	 26 }

	结果：
	1,Apple                        ,23500
	2,LaDoris                      ,1450
	3,Zhangfei                     ,1400
	4,Mark                         ,1450
	5,Audry                        ,1550
	6,Molly                        ,1200
	7,Roberta                      ,1250
	8,Ben                          ,1100
	9,Antoinette                   ,1300
	10,Marta                        ,1307
	11,Colin                        ,1400
	12,Henry                        ,1490
	13,Yasmin                       ,1515
	14,Mai                          ,1525
	15,Andre                        ,1450
	16,Elena                        ,1400
	17,George                       ,940
	18,Akira                        ,1200
	19,Vikram                       ,795
	20,Chad                         ,750
	21,Alexander                    ,850
	22,Eddie                        ,800
	23,Radha                        ,795
	24,Bela                         ,860
	25,Sylvie                       ,1100




	c. 用游标解决多行多列的查询问题
	   游标的编程步骤：
	   1.声明游标
		exec sql declare 游标名 cursor for select 语句;
	   2.打开游标
		exec sql open 游标名；
	   3.提取数据
		exec sql fetch 游标名 into :宿主变量;
	   4.关闭游标
		exec sql close 游标名;

	注意：游标在fetch数据时需要使用循环 
		循环退出的条件用：exec sql whenever notfound do break;

	  1 #include<stdio.h>
	  2 exec sql include sqlca;
	  3 struct emp{
	  4     int id;
	  5     char name[30];
	  6     double salary;
	  7 };
	  8 
	  9 int main()
	 10 {
	 11     exec sql begin declare section;
	 12      char userpasswd[30]="openlab/open123";
	 13      struct emp em;
	 14     exec sql end declare section;
	 15     exec sql connect:userpasswd;
	 16     exec sql whenever notfound do break;
	 17     /*声明游标*/
	 18     exec sql declare empcur cursor for
	 19         select id,first_name,salary from s_emp;
	 20     /*打开游标*/
	 21     exec sql open empcur;
	 22     /*提取数据*/
	 23     while(1)
	 24     {
	 25         exec sql fetch empcur into :em;
	 26         printf("%d,%s,%lg\n",em.id,em.name,em.salary);
	 27     }
	 28     /*关闭游标*/
	 29     exec sql close empcur;
	 30     exec sql commit work release;
	 31     return 0;
	 32 }

	结果：
	1,Apple                        ,23500
	2,LaDoris                      ,1450
	3,Zhangfei                     ,1400
	4,Mark                         ,1450
	5,Audry                        ,1550
	6,Molly                        ,1200
	7,Roberta                      ,1250
	8,Ben                          ,1100
	9,Antoinette                   ,1300
	10,Marta                        ,1307
	11,Colin                        ,1400
	12,Henry                        ,1490
	13,Yasmin                       ,1515
	14,Mai                          ,1525
	15,Andre                        ,1450
	16,Elena                        ,1400
	17,George                       ,940
	18,Akira                        ,1200
	19,Vikram                       ,795
	20,Chad                         ,750
	21,Alexander                    ,850
	22,Eddie                        ,800
	23,Radha                        ,795
	24,Bela                         ,860
	25,Sylvie                       ,1100


	有一种特殊的游标，叫做滚动游标。滚动游标可以直接跳到任何一行（滚动游标用的不多）
	滚动游标在用法上和普通游标有两个区别：
	1.声明时，scroll cursor
		exec sql declare 游标名 scroll cursor for select 语句；

	2.fetch时，滚动游标有多种方式读取数据
		fetch first	--取第一条数据
		fetch last 	--取最后一条数据
		fetch next	--取下一条数据
		fetch proir	--取上一条数据
		fetch absolute n--取第n条
		fetch current	--取当前数据
	
	  exec sql fetch last 游标名 into :宿主变量


	  1 #include<stdio.h>
	  2 exec sql include sqlca;
	  3 struct emp{
	  4     int id;
	  5     char name[30];
	  6     double salary;
	  7 };
	  8 
	  9 int main()
	 10 {
	 11     exec sql begin declare section;
	 12      char userpasswd[30]="openlab/open123";
	 13      struct emp em;  
	 14     exec sql end declare section;
	 15     exec sql connect:userpasswd;
	 16     /*声明游标*/
	 17     exec sql declare empcur scroll cursor for
	 18         select id,first_name,salary from s_emp;
	 19     /*打开游标*/
	 20     exec sql open empcur;
	 21     /*提取数据*/
	 22         exec sql fetch first empcur into :em;
	 23         printf("%d,%s,%lg\n",em.id,em.name,em.salary);
	 24         exec sql fetch last empcur into :em;
	 25         printf("%d,%s,%lg\n",em.id,em.name,em.salary);
	 26         exec sql fetch absolute 9 empcur into :em;
	 27         printf("%d,%s,%lg\n",em.id,em.name,em.salary);
	 28     /*关闭游标*/ 
	 29     exec sql close empcur;
	 30     exec sql commit work release; 
	 31     return 0; 
	 32 }

	结果：
	1,Apple                        ,23500
	25,Sylvie                       ,1100
	9,Antoinette                   ,1300



六. 动态SQL
	普通编程，所有的代码在编译时就确定了，
	动态编程就是代码在编译时没有确定，在运行时由传入的参数决定

	动态sql就是sql语句只有在运行时，通过参数传入确定
	
	proc中的动态sql有以下几种：

	1.非 select 语句，没有占位符（没有宿主变量） --占位符可以给sql语句传递参数
	char strsql[100]="create table test(id number,...)";
	exec sql execute immediate :strsql;

   	2.非select语句，有占位符
     	使用prepare命令准备sql语句
     	exec sql prepare s from :strsql;
     	使用execute命令执行sql语句
     	exec sql execute s using :宿主变量;
   
     	char strsql[100]="insert into ..... values(:b0,:b1,..)";
     	exec sql prepare s from :strsql;
     	exec sql execute s using :宿主变量;

  	3.select语句
     	char strsql[100]="select .... from .... where id>:b0";
     	exec sql prepare s from :strsql;
     	exec sql declare 游标 cursor for s;


1.不带占位符的非查询操作 建表

#include<stdio.h>
#include<string.h>
exec sql include sqlca;

int main()
{
        exec sql begin declare section;
                char userpasswd[30]="openlab/open123";
                char strsql[100];
        exec sql end declare section;
        exec sql connect:userpasswd;
        
        strcpy(strsql,"create table testdsql_wkw(id number,name varchar2(20))");
        exec sql execute immediate :strsql;
        
        exec sql commit work release;
        return 0;
}  


2.带占位符的非查询操作 insert

#include<stdio.h>
#include<string.h>
exec sql include sqlca;

int main()
{
        exec sql begin declare section;
                char userpasswd[30]="openlab/open123";
                char strsql[100];
		int id=10；
		char name[25]="test10";
        exec sql end declare section;
        exec sql connect:userpasswd;
        
        strcpy(strsql,"insert into testdsql_wkw values(:b0,:b1)");
	exec sql prepare s from :strsql;
	exec sql execute s using :id,:name;
        exec sql execute immediate :strsql;
        
        exec sql commit work release;
        return 0;
}  


3.带占位符的查询操作
	根据条件查看员工的id，first_name,salary

#include<stdio.h>
#include<string.h>
exec sql include sqlca;
struct emp{
	int id;
	char name[30];
	double salary;
};
int main()
{
        exec sql begin declare section;
                char userpasswd[30]="openlab/open123";
                char strsql[100];
		int id=10；
		struct emp em;
        exec sql end declare section;
        exec sql connect:userpasswd;
        
        strcpy(strsql,"select id,first_name,salary from s_emp where id>:b0");
	exec sql prepare s from :strsql;
	exec sql declare empcur cursor for s;
	exec sql open empcur using :id;
	exec sql whenever notfound do break;
	while(1)
	{
		exec sql fetch empcue into :em;
		printf("%d,%s,%lg\n",em.id,em.name,em.salary);
	}
        exec sql execute immediate :strsql;
        
        exec sql commit work release;
        return 0;
}  
























































